--------------------------------------------------------
## TOPICS ##
--------------------------------------------------------
# Phase 1: The Foundation (Syntax & Logic)
- Target: Being able to write simple scripts and solve algorithmic problems.

    [+] Structure & Syntax: [+]
        - Solution/Project: The whole box (your application)
        - Namespace: A logical grouping like a folder or a section in a library. It prevents naming conflicts
        - Class: The specific blueprint for an object (like "Customer" or "Product")
        - Method: An action that the class can do (like "CalculateTax" or "SaveToDatabase")
        - Statement: A single ilne of instruction

        - Real World Example (E-commerce System)
            - Namespace: Amazon.Paymentsystem -> This tels us we are in the Payment section of the app
            - Class: CreditCardProcessor -> This is the specific tool we are using
            - Method: ProcessTransaction() -> This is the action happening
            - Statement: DeductMoney(100); -> The actual line of code doing the work

    [+] Variables & Data Types:
        - Core Data Types
            - int: Whole numbers. Used for counting
            - double: Numbers with decimals. Used for general math, physics, or graphics
            - decimal: High-precision decimal numbers. Crucial for money
            - string: Text
            - bool: True or false

        - Database Mapping
            - int -> SQL Database INT
            - string -> SQL Database VARCHAR
            - bool -> SQL Database BIT (0 or 1)

    [+] Control Flow:
        - Control flows is how you give your program a "brain".
        - Without it, your code is just a list of instructions that runs once from top to bottom and dies
        - Control flow allows you program to:
            - Make Decisions: If x happens, do Y (if-else, switch)
            - Repeat Actions: Do this 50 times(for, foreach, while)

    [+] Methods (Functions):
        - A method is a reusable block of code that does one specific task
        - Think of your Main method as the "Manager" of a factory. The manager shouldn't be thightening bolts or packing boxes.
        - The Manager should just shout commands: "Start Machine", "Process Order", "Shut Down"
        - Methods are those specific commands

        - The Anatomy Of A Methods:
            - Input(Parameters): What does the tool need to work
            - Logic(Body): What does the tool do
            - Output(Return Type) What does the tool give back in response

# Phase 2: Object-Oriented Programming (OOP)
- Target: Structuring code into reusable, modular blocks.

    [+] Classes & Objects:
        - The Class:
            - It defines what something is and what it can do.
            - It doesn't exis in the real world yet. It's just a file on your computer
                > Example: Car
        
        - The Object:
            - It is the specific version created from the blueprint. It takes up memory
                > Example: Ferrari 488 (Red), Toyota Corolla (White)

        - Why do we need this -> In your Trading Bot, you dont want variables like goldPrice, silverPrice, oilPrice.
        - You want a blueprint called "Asset", and then you create 3 objects from it

        - C# read the Asset bluepring
        - It reserved memory for asset1 and stored Gold data there
        - It reserved separate memory for asset2 and stored Bitcoin there
        - When you called "PrintInfo()", the objects looked at their own internal memory to print the correct data

        - Constructor:
            - A constructor is a special method that runs "automatically" the moment you create an object (when you use the "new" keyword)
            - Think of it like opening a Bank Account. The bank won't let you just "open" an account and then decide your name and deposit money later
            - They force you to privde your "Name" and "Initial Deposit" right at the start
            - Constructors force your code to follow the same rules: "You cannot create an Asset unless you tell me its Name and Price immediately"
            - A contructor looks like a method but:
                - Ith as "no return type"
                - It has the "exact same name" as the class

            - Multiple Constructors (Overloading)
                - Just like methods, you can have multiple constructors
                - Imagine you want to support an asset where you don't know hte price yet
            
                > public Asset(string name, string symbol) {
                    this.Name = name;
                    this.Symbol = symbol;
                    this.Price = 0; // Default value
                }

    > The 4 Pillars of OOP:
        - Encapsulation: Protecting your data (The Shield)
        - Inheritance: Reusing code (The Family Tree)
        - Polymorphism: Flexible code (The Shape-Shifter)
        - Abstraction: Hiding Complexity (The Interface)

        > Encapsulation:
            - The Problem: you Asset class looks like this
                > public decimal Price
            - Because it is public, anyone can do this in Main:
                > gold.Price = -5000; // IMPOSSIBLE! Gold cannot have a nagative price
            - Your program will run, but your logic is corrupted. This is a bug
            - Solution: We use "encapsulation" to hide the real data (private) and control how it's accessed using Properties (public)
            - The wires (Private Field): You cannot touch the raw wires. You might get shocked or break it
            - The Dial (Public Property): You can only turn the dial

        > Inheritance
            - Inheritance allows you to create a new class based on an existing class
            - It is the ultimate tool for laziness
            - It follows the DRY Principle
            - The Concept: Imagine you are building game with Vehicles
                - You have a Car, a Truck, and a Motorcycle
                - They ALL have Speed, Color and Engine
                - If you write the code for Speed 3 separate times, you are wasting time
                - Instead, you create a parent class Vehicle with speed/color and the others inherit from it

                - The Hierarchy
                    - We are going to expand our Trading Bot. Currently, you just have Asset. But in reality:
                        - Stocks have "Dividends"
                        - Crypto has "Wallet Addresses"
                        - Gold has "Purity"
                    - They are ALL Assets (they all have Price and Name), but they have specific extras
                    - The 'Is-A' Rule:
                        - A Stock 'is an' Asset (Inheritance +)
                        - A Crypto 'is an' Asset (Inheritance +)
                        - A Bank 'has an' Asset (Inheritance -)

                    - The Syntax: in C#, symbol for inheritance -> :

                    > public class Asset {
                        public decimal Price;
                    }

                    public class Stock : Asset {
                        public decimal Dividend;
                        // It automatically has 'Price' too!

                        public Stock(string name, decimal price, decimal dividend) : base(name, price) {
                            this.Dividend = dividend;
                        }
                    }

                    public class Crypto : Asset {
                        public string WalletAddress;

                        public Crypto(string name, decimal price, string walletAddress) : base(name, price) {
                            this.WalletAddress = walletAddress;
                        }
                    }

                    Stock apple = new Stock("Apple", 5123.00m, 1.5m);
                    Crypto bitcoin = new Crypto("Bitcoin", 95000.00m, "0x123abc...");

                    apple.PrintInfo(); // Comes from parent class -> Asset
                    bitcoin.PrintInfo();

                    // apple.Dividend | bitcoin.walletAddress

                - Summary
                    - You defined "PrintInfo" once in the parent Asset, but both Stock and Crypto can use it
                    - This code reuse

    > Interfaces:

Phase 3: Intermediate C# (The Toolset)
Target: Handling data efficiently and writing cleaner code.

    > Collections (Data Structures):

    > Generics:

    > Exception Handling:

    > File I/O:

    > LINQ (Language Integrated Query): **(Crucial) **

# Phase 4: Advanced C# (Professional Level)
- Target: Writing high-performance, asynchronous code (Essential for backend/trading bots).

    > Asynchronous Programming: **(Most Important) **

    > Delegates & Events:

    > Advanced OOP:

    > Reflection & Attributes: